

# ðŸ”§ Implement Roofr PDF â†’ JSON (Server Only)

**Goal:** Add a Next.js 15 Server Action that parses a Roofr-style PDF and returns typed JSON, including **recommended waste %** (explicit when present, heuristic otherwise).

**Dependencies:**


**Runtime:** Node (not Edge).

---

## 1) Create Types â€” `lib/roofr/types.ts`

```ts
export type FeetInches = { feet: number; inches: number; raw: string };

export type LinearMeasurements = {
  eaves?: FeetInches;
  valleys?: FeetInches;
  hips?: FeetInches;
  ridges?: FeetInches;
  rakes?: FeetInches;
  wallFlashing?: FeetInches;
  stepFlashing?: FeetInches;
  transitions?: FeetInches;
  parapetWall?: FeetInches;
  unspecified?: FeetInches;
};

export type AreaTotals = {
  totalRoofAreaSqft?: number;
  totalPitchedAreaSqft?: number;
  totalFlatAreaSqft?: number;
  totalRoofFacets?: number;
  predominantPitch?: string; // e.g., "7/12"
};

export type PitchBreakdown = {
  pitch: string;
  areaSqft: number;
  squares: number;
}[];

export type WasteRecommendationRow = {
  wastePercent: number;
  areaSqft: number;
  squares: number;
};

export type WasteRecommendations = WasteRecommendationRow[];

export type MaterialCalcRow = {
  name: string;
  unit: string;              // "sqft" | "bundle" | "roll" | "ft" | "sheet" | "unit"
  waste10?: string;
  waste15?: string;
  waste17?: string;
  waste20?: string;
};

export type MaterialCalcSection = {
  section: string;           // "Shingle", "Starter", "Ice and Water", ...
  rows: MaterialCalcRow[];
};

export interface RoofrReportJson {
  fileName?: string;
  address?: string;
  nearMapDate?: string;
  pageCount?: number;

  linear: LinearMeasurements;
  areas: AreaTotals;
  pitchBreakdown: PitchBreakdown;

  wasteRecommendations: WasteRecommendations;

  /** Which waste % is recommended (explicitly or by heuristic) */
  recommendedWastePercents: number[];
  recommendationMethod: "explicit" | "heuristic";
  recommendationNotes?: string;

  materialCalculations: MaterialCalcSection[];

  _debug?: {
    matchedSections: string[];
  };
}
```

---

## 2) Create Parser â€” `lib/roofr/parser.ts`

```ts
import type {
  RoofrReportJson, FeetInches, LinearMeasurements, AreaTotals,
  PitchBreakdown, WasteRecommendations, MaterialCalcSection, MaterialCalcRow
} from "./types";

const toNumber = (s?: string | null) => (s ? Number(s.replace(/[^0-9.\-]/g, "")) : NaN);

export function parseFeetInches(raw: string): FeetInches | undefined {
  const m = raw.match(/(\d+)\s*ft\s*(\d+)\s*in/i);
  if (!m) return;
  return { feet: Number(m[1]), inches: Number(m[2]), raw: m[0] };
}

function matchAfter(text: string, label: string, pattern: RegExp): RegExpMatchArray | null {
  const idx = text.indexOf(label);
  if (idx === -1) return null;
  const tail = text.slice(idx);
  return tail.match(pattern);
}

function extractAddress(text: string): string | undefined {
  const addr = text.match(/\n([0-9]{1,6}[^,\n]+\,[^\n]+[A-Z]{2}\s*\d{5})/);
  return addr ? addr[1].trim() : undefined;
}

function extractNearmap(text: string): string | undefined {
  const n = text.match(/Nearmap\s+([A-Za-z]{3}\s+\d{1,2},\s+\d{4})/i);
  return n ? n[1] : undefined;
}

function extractLinearMeasurements(text: string): LinearMeasurements {
  const names: Record<string, keyof LinearMeasurements> = {
    "Eaves": "eaves",
    "Valleys": "valleys",
    "Hips": "hips",
    "Ridges": "ridges",
    "Rakes": "rakes",
    "Wall flashing": "wallFlashing",
    "Step flashing": "stepFlashing",
    "Transitions": "transitions",
    "Parapet wall": "parapetWall",
    "Unspecified": "unspecified"
  };

  const out: LinearMeasurements = {};
  const re = new RegExp(
    "(Eaves|Valleys|Hips|Ridges|Rakes|Wall flashing|Step flashing|Transitions|Parapet wall|Unspecified)\\s*:\\s*(\\d+ft\\s*\\d+in)",
    "gi"
  );

  let m: RegExpExecArray | null;
  while ((m = re.exec(text))) {
    const key = names[m[1]];
    const len = parseFeetInches(m[2]);
    if (key && len) out[key] = len;
  }
  return out;
}

function extractAreaTotals(text: string): AreaTotals {
  const findNum = (label: string) => {
    const m = matchAfter(text, label, new RegExp(label + "\\s+(\\d+[\\d,\\.]*)\\s*sqft", "i"));
    return m ? toNumber(m[1]) : undefined;
  };

  const totals: AreaTotals = {
    totalRoofAreaSqft: findNum("Total roof area"),
    totalPitchedAreaSqft: findNum("Total pitched area"),
    totalFlatAreaSqft: findNum("Total flat area"),
  };

  const facets = matchAfter(text, "Total roof facets", /Total roof facets\s+(\d+)\s+facets/i);
  if (facets) totals.totalRoofFacets = Number(facets[1]);

  const pitch = matchAfter(text, "Predominant pitch", /Predominant pitch\s+([0-9/]+)/i);
  if (pitch) totals.predominantPitch = pitch[1];

  return totals;
}

function extractPitchBreakdown(text: string): PitchBreakdown {
  const header = text.match(/Pitch\s+([0-9/ \t]+)\n+Area\s*\(sqft\)\s+([0-9 \t,\.]+)\n+Squares\s+([0-9 \t,\.]+)/i);
  if (!header) return [];
  const pitches = header[1].trim().split(/\s+/);
  const areas = header[2].trim().split(/\s+/).map(v => toNumber(v));
  const squares = header[3].trim().split(/\s+/).map(v => toNumber(v));
  const out: PitchBreakdown = [];
  for (let i = 0; i < pitches.length; i++) {
    if (!pitches[i]) continue;
    out.push({
      pitch: pitches[i],
      areaSqft: Number(areas[i] ?? 0),
      squares: Number(squares[i] ?? 0),
    });
  }
  return out;
}

function extractWasteRecommendations(text: string): WasteRecommendations {
  const m = text.match(
    /Waste\s*%\s*([0-9% \t]+)\n+Area\s*\(sqft\)\s*([0-9, \t\.]+)\n+Squares\s*([0-9 \t\.]+)/i
  );
  if (!m) return [];
  const perc = m[1].trim().split(/\s+/).map(p => toNumber(p));
  const areas = m[2].trim().split(/\s+/).map(v => toNumber(v));
  const squares = m[3].trim().split(/\s+/).map(v => toNumber(v));

  const out = [];
  for (let i = 0; i < perc.length; i++) {
    out.push({
      wastePercent: Number(perc[i]),
      areaSqft: Number(areas[i] ?? 0),
      squares: Number(squares[i] ?? 0),
    });
  }
  return out;
}

function normalizeUnitCell(s: string): string {
  return s.replace(/\s+/g, " ").trim();
}

function sectionNameFromHeader(line: string): string {
  const m = line.match(/^([A-Za-z ]+)\s*\(/);
  return m ? m[1].trim() : line.trim();
}

function inferUnitFromHeader(line: string): string {
  const m = line.match(/\(([^)]+)\)/);
  if (!m) return "unit";
  const within = m[1].toLowerCase();
  if (within.includes("sqft")) return "sqft";
  if (within.includes("ft")) return "ft";
  return within;
}

function inferUnitFromRowName(name: string): string {
  if (/bundle/i.test(name)) return "bundle";
  if (/roll/i.test(name)) return "roll";
  if (/sheet/i.test(name)) return "sheet";
  if (/ft\b/i.test(name)) return "ft";
  if (/sqft/i.test(name)) return "sqft";
  return "unit";
}

function extractMaterialCalculations(text: string): MaterialCalcSection[] {
  const start = text.indexOf("Material calculations");
  if (start === -1) return [];
  const end = text.indexOf("This report was prepared", start + 10);
  const block = text.slice(start, end === -1 ? undefined : end);

  const lines = block.split(/\r?\n/).map(l => l.trim()).filter(Boolean);

  const sections: MaterialCalcSection[] = [];
  let current: MaterialCalcSection | null = null;

  const pushRow = (name: string, unitHint?: string, w10?: string, w15?: string, w17?: string, w20?: string) => {
    const row: MaterialCalcRow = {
      name: name.trim(),
      unit: unitHint || inferUnitFromRowName(name),
      waste10: w10 ? normalizeUnitCell(w10) : undefined,
      waste15: w15 ? normalizeUnitCell(w15) : undefined,
      waste17: w17 ? normalizeUnitCell(w17) : undefined,
      waste20: w20 ? normalizeUnitCell(w20) : undefined,
    };
    current?.rows.push(row);
  };

  const headerRegex = /^Product\s+Unit\s+Waste/i;

  for (const line of lines) {
    if (/^Material calculations/i.test(line)) continue;
    if (headerRegex.test(line)) continue;

    const secMatch = line.match(/^([A-Za-z ]+\([^)]+\)|[A-Za-z ]+)\s+([\d,\.]+\s*\w+)\s+([\d,\.]+\s*\w+)\s+([\d,\.]+\s*\w+)\s+([\d,\.]+\s*\w+)$/);
    if (secMatch) {
      const header = secMatch[1];
      const section = sectionNameFromHeader(header);
      current = { section, rows: [] };
      sections.push(current);

      const unitHint = inferUnitFromHeader(header);
      pushRow(header, unitHint, secMatch[2], secMatch[3], secMatch[4], secMatch[5]);
      continue;
    }

    const brandRow = line.match(/^(.+?)\s+(bundle|roll|sheet|sqft|ft)\s+([\d,\.]+)\s+([\d,\.]+)\s+([\d,\.]+)\s+([\d,\.]+)$/i);
    if (brandRow) {
      const [, name, unit, w10, w15, w17, w20] = brandRow;
      pushRow(name, unit, w10, w15, w17, w20);
      continue;
    }
  }

  return sections;
}

/** â€”â€”â€” Recommendation helpers â€”â€”â€” */

function feetInchesToFeet(f?: FeetInches) {
  if (!f) return 0;
  return f.feet + (f.inches || 0) / 12;
}

function nearestAvailable(target: number, options: number[]) {
  if (!options.length) return [];
  let best = options[0];
  let bestDiff = Math.abs(options[0] - target);
  for (const o of options.slice(1)) {
    const d = Math.abs(o - target);
    if (d < bestDiff) { best = o; bestDiff = d; }
  }
  return [best];
}

function extractExplicitRecommended(text: string): number[] {
  const hits = new Set<number>();
  const re1 = /Recommended\s*[:\-]?\s*(\d{1,2})\s*%/ig;
  const re2 = /(\d{1,2})\s*%\s*\(recommended\)/ig;

  let m: RegExpExecArray | null;
  while ((m = re1.exec(text))) hits.add(Number(m[1]));
  while ((m = re2.exec(text))) hits.add(Number(m[1]));

  return [...hits].sort((a,b)=>a-b);
}

function recommendWasteHeuristic(
  linear: LinearMeasurements,
  areas: AreaTotals,
  pitchBreakdown: PitchBreakdown,
  availablePercents: number[]
): { recs: number[]; notes: string } {
  let score = 0;
  const valleysFt = feetInchesToFeet(linear.valleys);
  if (valleysFt > 50) score += 1;
  if (valleysFt > 100) score += 1;

  const hipsFt = feetInchesToFeet(linear.hips);
  const ridgesFt = feetInchesToFeet(linear.ridges);
  if (hipsFt + ridgesFt > 120) score += 1;

  const facets = areas.totalRoofFacets || 0;
  if (facets >= 6) score += 1;
  if (facets >= 9) score += 1;

  const uniquePitches = new Set(pitchBreakdown.map(p => p.pitch)).size;
  if (uniquePitches >= 3) score += 1;

  const pred = areas.predominantPitch;
  const predNum = pred ? Number((pred.split("/")[0] || "0")) : 0;
  if (predNum >= 9) score += 1;

  const target = score <= 1 ? 10
               : score === 2 ? 12
               : score === 3 ? 15
               : score === 4 ? 17
               : score === 5 ? 20
               : 22;

  const recs = nearestAvailable(target, availablePercents);
  const notes =
    `Heuristic: score=${score} (valleys ${valleysFt.toFixed(1)}ft, hips+ridges ${(hipsFt+ridgesFt).toFixed(1)}ft, ` +
    `facets ${facets}, pitchVar ${uniquePitches}, predominant ${pred || "n/a"}) â†’ target ${target}%.`;

  return { recs, notes };
}

/** â€”â€”â€” Main parser â€”â€”â€” */
export function parseRoofrPdf(fullText: string, fileName?: string, pageCount?: number): RoofrReportJson {
  const address = extractAddress(fullText);
  const nearMapDate = extractNearmap(fullText);
  const linear = extractLinearMeasurements(fullText);
  const areas = extractAreaTotals(fullText);
  const pitchBreakdown = extractPitchBreakdown(fullText);
  const wasteRecommendations = extractWasteRecommendations(text = fullText);

  const availablePercents = wasteRecommendations.map(w => w.wastePercent).filter(n => !Number.isNaN(n));
  let recommendedWastePercents: number[] = [];
  let recommendationMethod: "explicit" | "heuristic" = "heuristic";
  let recommendationNotes: string | undefined;

  const explicit = extractExplicitRecommended(fullText).filter(p => availablePercents.includes(p));
  if (explicit.length) {
    recommendedWastePercents = explicit;
    recommendationMethod = "explicit";
    recommendationNotes = "Detected explicit recommendation in PDF text.";
  } else {
    const h = recommendWasteHeuristic(linear, areas, pitchBreakdown, availablePercents);
    recommendedWastePercents = h.recs;
    recommendationNotes = h.notes;
  }

  const materialCalculations = extractMaterialCalculations(fullText);

  const matchedSections = [
    address ? "address" : "",
    nearMapDate ? "nearmap" : "",
    Object.keys(linear).length ? "linear" : "",
    areas.totalRoofAreaSqft ? "areas" : "",
    pitchBreakdown.length ? "pitch" : "",
    wasteRecommendations.length ? "waste" : "",
    recommendedWastePercents.length ? "recommendedWaste" : "",
    materialCalculations.length ? "materials" : ""
  ].filter(Boolean);

  return {
    fileName,
    pageCount,
    address,
    nearMapDate,
    linear,
    areas,
    pitchBreakdown,
    wasteRecommendations,
    recommendedWastePercents,
    recommendationMethod,
    recommendationNotes,
    materialCalculations,
    _debug: { matchedSections }
  };
}
```

---

## 3) Create Server Action â€” `app/actions/parseRoofReport.ts`

```ts
"use server";

import pdfParse from "pdf-parse";
import crypto from "node:crypto";
import { parseRoofrPdf } from "@/lib/roofr/parser";
import type { RoofrReportJson } from "@/lib/roofr/types";

// Ensure Node runtime (pdf-parse needs Node)
export const runtime = "nodejs";

export async function parseRoofReportAction(formData: FormData): Promise<
  | { ok: true; documentHash: string; data: RoofrReportJson }
  | { ok: false; error: string }
> {
  try {
    const file = formData.get("file");
    if (!(file instanceof File)) {
      return { ok: false, error: "Expected FormData field `file` as a PDF." };
    }
    if (!/\.pdf$/i.test(file.name)) {
      return { ok: false, error: "File must be a .pdf" };
    }

    const buf = Buffer.from(await file.arrayBuffer());

    // Use provided documentHash or compute one from file
    const externalDocHash = (formData.get("documentHash") as string) || "";
    const documentHash =
      externalDocHash || crypto.createHash("sha256").update(buf).digest("hex");

    // Optional metadata passthrough
    const _userId = (formData.get("userId") as string) || "";

    const parsed = await pdfParse(buf); // -> { text, numpages, info, ... }
    const data = parseRoofrPdf(parsed.text, file.name, parsed.numpages);

    // TODO: integrate storage/persistence here if needed:
    // await saveFile(buf, documentHash)
    // await saveJson(data, `${documentHash}.json`)

    return { ok: true, documentHash, data };
  } catch (err: any) {
    return { ok: false, error: err?.message ?? "Failed to parse PDF" };
  }
}
```

---

## 4) Integration Notes (Server Only)

* Import and call `parseRoofReportAction` from your Dashboard page/form via `useActionState` or a `<form action={parseRoofReportAction}>â€¦`.
* Pass a `FormData` with `file` (`File` object of the PDF). Optionally include `userId` and `documentHash`.
* The action returns:

  * `data: RoofrReportJson` (measurements, tables, **recommendedWastePercents**, etc.)
  * `documentHash` (sha256 of file if not provided)
* Persist to your DB/storage in the TODO section if required.

**Client-side UI:** Implement via the **Dashboard** (your existing patterns/components). Do not generate new client files here.
